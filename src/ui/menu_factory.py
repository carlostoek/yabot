"""
Unified Menu Factory System for YABOT
Manages role-based menu generation with consistency across the entire system.
"""

from typing import Dict, List, Any, Optional, Union, Tuple
from enum import Enum
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
import logging
import json
import hashlib
import asyncio
from datetime import datetime

# Import Lucien voice generation system for sophisticated interface personality
from src.ui.lucien_voice_generator import (
    LucienVoiceProfile,
    generate_lucien_response,
    RelationshipLevel,
    LucienPersonalityConstants
)

# Import centralized menu configuration
from src.ui.menu_config import (
    MenuType,
    ActionType,
    UserRole,
    MenuItemConfig,
    MenuConfig,
    menu_system_config
)

# Import UserService for delegation of complex operations
from src.services.user import UserService

logger = logging.getLogger(__name__)

# Telegram Bot API constants
TELEGRAM_CALLBACK_DATA_MAX_LENGTH = 64
TELEGRAM_MAX_INLINE_BUTTONS_PER_ROW = 8
TELEGRAM_MAX_INLINE_KEYBOARD_ROWS = 100


class MenuError(Exception):
    """Base exception for menu-related errors."""
    pass


class CallbackDataTooLongError(MenuError):
    """Raised when callback data exceeds Telegram's limit."""
    pass


class MenuGenerationError(MenuError):
    """Raised when menu generation fails."""
    pass


class ValidationError(MenuError):
    """Raised when menu validation fails."""
    pass


@dataclass
class MenuItem:
    """Represents a single menu item with all necessary properties."""
    id: str
    text: str
    action_type: ActionType
    action_data: str
    icon: str = "üìã"
    description: str = ""
    required_role: UserRole = UserRole.FREE_USER
    required_vip: bool = False
    required_level: int = 0
    requires_besitos: int = 0
    visible_condition: Optional[str] = None
    enabled_condition: Optional[str] = None
    submenu_items: List['MenuItem'] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    lucien_voice_text: Optional[str] = None
    required_worthiness: float = 0.0  # Lucien's evaluation score

    def __post_init__(self) -> None:
        """Validate menu item after initialization."""
        self._validate_callback_data()
        self._add_role_indicators()
        self._set_lucien_voice_text()

    @classmethod
    def from_config(cls, config: MenuItemConfig) -> 'MenuItem':
        """Create MenuItem from MenuItemConfig."""
        return cls(
            id=config.id,
            text=config.text,
            action_type=config.action_type,
            action_data=config.action_data,
            icon=config.icon,
            description=config.description,
            required_role=config.required_role,
            required_vip=config.required_vip,
            required_level=config.required_level,
            requires_besitos=config.requires_besitos,
            visible_condition=config.visible_condition,
            enabled_condition=config.enabled_condition,
            metadata=config.metadata,
            required_worthiness=config.required_worthiness
        )

    def _set_lucien_voice_text(self) -> None:
        """Set Lucien voice text if not provided."""
        if self.lucien_voice_text is None:
            # For now, we'll just use the regular text as a fallback
            # In a full implementation, this would be generated by Lucien's voice generator
            self.lucien_voice_text = self.text

    def _validate_callback_data(self) -> None:
        """Validate that callback data doesn't exceed Telegram's limit."""
        if len(self.action_data.encode('utf-8')) > TELEGRAM_CALLBACK_DATA_MAX_LENGTH:
            # Try to compress the callback data
            compressed_data = self._compress_callback_data(self.action_data)
            if len(compressed_data.encode('utf-8')) > TELEGRAM_CALLBACK_DATA_MAX_LENGTH:
                logger.error(
                    f"Callback data too long for item '{self.id}': {len(self.action_data)} bytes, "
                    f"compressed: {len(compressed_data)} bytes"
                )
                raise CallbackDataTooLongError(
                    f"Callback data for '{self.id}' exceeds {TELEGRAM_CALLBACK_DATA_MAX_LENGTH} bytes"
                )
            else:
                logger.warning(
                    f"Compressed callback data for item '{self.id}': {len(self.action_data)} -> {len(compressed_data)} bytes"
                )
                self.action_data = compressed_data

    def _compress_callback_data(self, data: str) -> str:
        """Compress callback data using a mapping strategy."""
        # Create a hash-based mapping for long action data
        if len(data) > TELEGRAM_CALLBACK_DATA_MAX_LENGTH - 10:  # Leave room for prefix
            data_hash = hashlib.md5(data.encode()).hexdigest()[:8]
            return f"hash:{data_hash}"
        return data

    def _add_role_indicators(self) -> None:
        """Add visual indicators for role requirements."""
        indicators = []

        if self.required_vip:
            indicators.append("üíé")

        if self.required_level > 0:
            indicators.append(f"Lv.{self.required_level}")

        if self.requires_besitos > 0:
            indicators.append(f"üí∞{self.requires_besitos}")

        if self.required_role not in [UserRole.FREE_USER, UserRole.GUEST]:
            role_symbols = {
                UserRole.VIP_USER: "‚≠ê",
                UserRole.ADMIN: "üîß",
                UserRole.SUPER_ADMIN: "üëë"
            }
            if self.required_role in role_symbols:
                indicators.append(role_symbols[self.required_role])

        if indicators:
            # Add indicators to the end of the text if not already present
            indicator_text = " ".join(indicators)
            if not any(indicator in self.text for indicator in indicators):
                self.text = f"{self.text} {indicator_text}"
                # Also update the lucien_voice_text if it's using the default text
                if self.lucien_voice_text == self.text or self.lucien_voice_text is None:
                    self.lucien_voice_text = self.text


@dataclass
class Menu:
    """Represents a complete menu with header, items, and context."""
    menu_id: str
    title: str
    description: str
    menu_type: MenuType
    required_role: UserRole
    items: List[MenuItem] = field(default_factory=list)
    header_text: str = ""
    footer_text: str = ""
    max_columns: int = 2
    is_dynamic: bool = False
    context_data: Dict[str, Any] = field(default_factory=dict)
    parent_menu_id: Optional[str] = None
    navigation_path: List[str] = field(default_factory=list)

    def __post_init__(self) -> None:
        """Validate menu after initialization."""
        self._validate_menu()
        self._add_navigation_items()

    @classmethod
    def from_config(cls, config: MenuConfig, user_context: Dict[str, Any] = None) -> 'Menu':
        """Create Menu from MenuConfig."""
        # Convert MenuItemConfig items to MenuItem objects
        menu_items = [MenuItem.from_config(item_config) for item_config in config.items]
        
        return cls(
            menu_id=config.menu_id,
            title=config.title,
            description=config.description,
            menu_type=config.menu_type,
            required_role=config.required_role,
            items=menu_items,
            header_text=config.header_text,
            footer_text=config.footer_text,
            max_columns=config.max_columns,
            is_dynamic=config.is_dynamic,
            parent_menu_id=config.parent_menu_id,
            navigation_path=config.navigation_path
        )

    def _validate_menu(self) -> None:
        """Validate menu structure and constraints."""
        # Validate total number of items
        if len(self.items) > TELEGRAM_MAX_INLINE_KEYBOARD_ROWS * TELEGRAM_MAX_INLINE_BUTTONS_PER_ROW:
            logger.warning(f"Menu '{self.menu_id}' has too many items: {len(self.items)}")

        # Validate menu hierarchy depth
        if len(self.navigation_path) > 5:  # Max 5 levels deep
            logger.warning(f"Menu '{self.menu_id}' is too deep in hierarchy: {len(self.navigation_path)} levels")

    def _add_navigation_items(self) -> None:
        """Add back navigation and home buttons to the menu."""
        navigation_items = []

        # Add back button if we have a parent or navigation path
        if self.parent_menu_id or self.navigation_path:
            back_target = self.parent_menu_id or (self.navigation_path[-1] if self.navigation_path else "main_menu")
            navigation_items.append(MenuItem(
                id="nav_back",
                text="<b>‚óÄÔ∏è Atr√°s</b>",
                action_type=ActionType.CALLBACK,
                action_data=f"menu:{back_target}",
                description="Volver al men√∫ anterior",
                icon="‚óÄÔ∏è"
            ))

        # Add home button if we're not already in main menu
        if self.menu_id != "main_menu":
            navigation_items.append(MenuItem(
                id="nav_home",
                text="<b>üè† Inicio</b>",
                action_type=ActionType.CALLBACK,
                action_data="menu:main_menu",
                description="Ir al men√∫ principal",
                icon="üè†"
            ))

        # Add navigation items to the menu (at the end)
        self.items.extend(navigation_items)


class MenuBuilder(ABC):
    """Abstract base class for menu builders."""

    @abstractmethod
    def build_menu(self, user_context: Dict[str, Any], **kwargs) -> Menu:
        """Build menu for specific user context."""
        pass

    def _log_menu_creation(self, menu_type: str, user_id: str, success: bool,
                          error: Optional[str] = None) -> None:
        """Log menu creation attempts for debugging."""
        timestamp = datetime.now().isoformat()
        if success:
            logger.info(f"[{timestamp}] Menu created successfully: {menu_type} for user {user_id}")
        else:
            logger.error(f"[{timestamp}] Menu creation failed: {menu_type} for user {user_id}. Error: {error}")

    def _validate_user_context(self, user_context: Dict[str, Any]) -> Dict[str, Any]:
        """Validate and normalize user context."""
        required_fields = ['role', 'user_id']
        for field in required_fields:
            if field not in user_context:
                logger.warning(f"Missing required field '{field}' in user context")
                if field == 'role':
                    user_context[field] = 'free_user'
                elif field == 'user_id':
                    user_context[field] = 'unknown'

        # Ensure role is valid
        try:
            UserRole(user_context['role'])
        except ValueError:
            logger.warning(f"Invalid role '{user_context['role']}', defaulting to free_user")
            user_context['role'] = 'free_user'

        return user_context


class MainMenuBuilder(MenuBuilder):
    """Builder for organic unified menu system that shows all options with elegant restrictions."""

    def __init__(self, user_service: Optional[UserService] = None):
        """Initialize MainMenuBuilder with Lucien voice profile.
        
        Args:
            user_service (Optional[UserService]): UserService instance for delegation of complex operations
        """
        self.lucien_profile = LucienVoiceProfile()
        self.user_service = user_service

    def build_menu(self, user_context: Dict[str, Any], **kwargs) -> Menu:
        """Build organic main menu that shows all options with elegant restrictions."""
        try:
            user_context = self._validate_user_context(user_context)
            user_id = user_context.get('user_id', 'unknown')
            user_role = UserRole(user_context.get('role', 'free_user'))
            has_vip = user_context.get('has_vip', False)
            narrative_level = user_context.get('narrative_level', 1)
            worthiness_score = user_context.get('worthiness_score', 0.0)
            besitos_balance = user_context.get('besitos_balance', 100)

            logger.info(f"Building organic menu for user {user_id} (role: {user_role.value}, vip: {has_vip}, level: {narrative_level})")

            self._adapt_lucien_voice_to_user(user_context)

            # Core navigation items - always visible
            items = [
                MenuItem(
                    id="historia_diana", text="<b>üé≠ Historia con Diana</b>", action_type=ActionType.SUBMENU,
                    action_data="narrative_menu", description="Tu narrativa personal en evoluci√≥n",
                    required_role=UserRole.FREE_USER, icon="üé≠"
                ),
                MenuItem(
                    id="experiencias_interactivas", text="<b>üéÆ Experiencias Interactivas</b>", action_type=ActionType.SUBMENU,
                    action_data="experiences_menu", description="Misiones, juegos y desaf√≠os",
                    required_role=UserRole.FREE_USER, icon="üéÆ"
                ),
                MenuItem(
                    id="coleccion_tesoros", text="<b>üè™ Colecci√≥n de Tesoros</b>", action_type=ActionType.SUBMENU,
                    action_data="organic_store_menu", description="Fragmentos, joyas y m√°scaras emocionales",
                    required_role=UserRole.FREE_USER, icon="üè™"
                ),
                MenuItem(
                    id="universo_personal", text="<b>üéí Mi Universo Personal</b>", action_type=ActionType.SUBMENU,
                    action_data="personal_universe_menu", description="Tu progreso y tesoros acumulados",
                    required_role=UserRole.FREE_USER, icon="üéí"
                )
            ]

            # Add El Div√°n with organic worthiness explanation if not accessible
            divan_item = self._create_divan_menu_item(user_context)
            items.append(divan_item)

            # Add admin panel for admins
            if user_role in [UserRole.ADMIN, UserRole.SUPER_ADMIN]:
                items.append(MenuItem(
                    id="admin_panel", text="<b>‚öôÔ∏è Panel Admin</b>", action_type=ActionType.SUBMENU,
                    action_data="admin_menu", description="Herramientas administrativas",
                    required_role=UserRole.ADMIN, icon="‚öôÔ∏è"
                ))

            # Process items with Lucien voice enhancements
            processed_items = []
            for item in items:
                item.lucien_voice_text = self._generate_lucien_menu_text(
                    item.id, item.description, user_context
                )
                processed_items.append(item)

            lucien_header = self._generate_lucien_welcome_message(user_context)
            lucien_footer = self._generate_lucien_footer_message(user_context)

            menu = Menu(
                menu_id="main_menu", title="üè† Tu Mundo con Diana",
                description="Un universo de posibilidades esper√°ndote",
                menu_type=MenuType.MAIN, required_role=UserRole.FREE_USER, items=processed_items,
                header_text=lucien_header, footer_text=lucien_footer, navigation_path=[]
            )

            self._log_menu_creation("main_menu", user_id, True)
            return menu

        except Exception as e:
            self._log_menu_creation("main_menu", user_context.get('user_id', 'unknown'), False, str(e))
            raise MenuGenerationError(f"Failed to build main menu: {str(e)}")

    def build_organic_store_menu(self, user_context: Dict[str, Any], **kwargs) -> Menu:
        """Build unified store menu showing all items with elegant restrictions."""
        try:
            user_context = self._validate_user_context(user_context)
            user_id = user_context.get('user_id', 'unknown')
            has_vip = user_context.get('has_vip', False)
            narrative_level = user_context.get('narrative_level', 1)
            worthiness_score = user_context.get('worthiness_score', 0.0)
            besitos_balance = user_context.get('besitos_balance', 100)

            items = [
                # Fragmentos Narrativos - Tier system
                MenuItem(
                    id="fragmentos_basicos", text="<b>üìö Fragmentos de Memoria</b>", action_type=ActionType.CALLBACK,
                    action_data="show_narrative_fragments", description="Momentos especiales revividos",
                    required_role=UserRole.FREE_USER, requires_besitos=50
                ),
                MenuItem(
                    id="fragmentos_premium", text="<b>üìö Fragmentos √çntimos</b> ‚ú®", action_type=ActionType.CALLBACK,
                    action_data=self._create_worthiness_check("premium_fragments", worthiness_score, 0.4),
                    description="Recuerdos de profundidad excepcional",
                    required_role=UserRole.FREE_USER, requires_besitos=150, required_worthiness=0.4
                ),

                # Joyas Emocionales - Progressive access
                MenuItem(
                    id="joyas_exploracion", text="<b>üíé Joyas de Exploraci√≥n</b>", action_type=ActionType.CALLBACK,
                    action_data="show_exploration_gems", description="Potenciadores de conexi√≥n emocional",
                    required_role=UserRole.FREE_USER, requires_besitos=80
                ),
                MenuItem(
                    id="joyas_intimidad", text="<b>üíé Joyas de Intimidad</b> ‚ú®", action_type=ActionType.CALLBACK,
                    action_data=self._create_worthiness_check("intimacy_gems", worthiness_score, 0.6),
                    description="Catalizadores de profundidad emocional suprema",
                    required_role=UserRole.FREE_USER, requires_besitos=300, required_worthiness=0.6
                ),

                # M√°scaras de Personalidad
                MenuItem(
                    id="mascaras_expresion", text="<b>üé≠ M√°scaras de Expresi√≥n</b>", action_type=ActionType.CALLBACK,
                    action_data="show_expression_masks", description="Nuevas formas de comunicarte con Diana",
                    required_role=UserRole.FREE_USER, requires_besitos=120
                ),

                # C√≠rculo √çntimo - VIP section with elegant presentation
                MenuItem(
                    id="circulo_intimo", text="<b>‚ú® C√≠rculo √çntimo</b> üí´", action_type=ActionType.SUBMENU,
                    action_data=self._create_vip_access_check("circulo_intimo", has_vip, worthiness_score),
                    description="Experiencias reservadas para los m√°s sofisticados",
                    required_role=UserRole.FREE_USER, required_worthiness=0.7
                )
            ]

            # Process each item with appropriate restrictions and Lucien voice
            processed_items = []
            for item in items:
                processed_item = self._process_store_item(item, user_context)
                processed_items.append(processed_item)

            lucien_header = self._generate_store_header(user_context)
            lucien_footer = self._generate_store_footer(user_context)

            menu = Menu(
                menu_id="organic_store_menu", title="üè™ Colecci√≥n de Tesoros",
                description="Cada objeto cuenta una historia, cada adquisici√≥n revela car√°cter",
                menu_type=MenuType.STORE, required_role=UserRole.FREE_USER, items=processed_items,
                header_text=lucien_header, footer_text=lucien_footer,
                parent_menu_id="main_menu"
            )

            self._log_menu_creation("organic_store_menu", user_id, True)
            return menu

        except Exception as e:
            self._log_menu_creation("organic_store_menu", user_context.get('user_id', 'unknown'), False, str(e))
            raise MenuGenerationError(f"Failed to build organic store menu: {str(e)}")

    def _create_divan_menu_item(self, user_context: Dict[str, Any]) -> MenuItem:
        """Create El Div√°n menu item with organic access explanation."""
        has_vip = user_context.get('has_vip', False)
        worthiness_score = user_context.get('worthiness_score', 0.0)
        narrative_level = user_context.get('narrative_level', 1)

        if has_vip and narrative_level >= 4 and worthiness_score >= 0.6:
            # Full access
            return MenuItem(
                id="el_divan_acceso", text="<b>üõãÔ∏è El Div√°n</b>", action_type=ActionType.SUBMENU,
                action_data="divan_menu", description="Tu espacio √≠ntimo de comprensi√≥n profunda",
                required_role=UserRole.FREE_USER, icon="üõãÔ∏è"
            )
        else:
            # Visible but with Lucien's elegant explanation
            worthiness_explanation = self._generate_worthiness_explanation(user_context)
            return MenuItem(
                id="el_divan_evaluacion", text="<b>üõãÔ∏è El Div√°n</b> ‚ú®", action_type=ActionType.CALLBACK,
                action_data="explain_divan_worthiness",
                description="Un privilegio que se gana a trav√©s del desarrollo personal",
                required_role=UserRole.FREE_USER, icon="üõãÔ∏è",
                lucien_voice_text=worthiness_explanation
            )

    def _create_worthiness_check(self, item_id: str, current_worthiness: float, required_worthiness: float) -> str:
        """Create action data for worthiness-gated items."""
        if current_worthiness >= required_worthiness:
            return f"access_granted:{item_id}"
        else:
            return f"worthiness_explanation:{item_id}:{required_worthiness}"

    def _create_vip_access_check(self, item_id: str, has_vip: bool, worthiness_score: float) -> str:
        """Create action data for VIP-gated items."""
        if has_vip and worthiness_score >= 0.5:
            return f"vip_access:{item_id}"
        else:
            return f"vip_invitation:{item_id}"

    def _process_store_item(self, item: MenuItem, user_context: Dict[str, Any]) -> MenuItem:
        """Process store item to add appropriate access logic and Lucien voice."""
        has_vip = user_context.get('has_vip', False)
        worthiness_score = user_context.get('worthiness_score', 0.0)
        besitos_balance = user_context.get('besitos_balance', 100)

        # Check if user meets requirements
        can_access = True
        restriction_reason = None

        if item.required_worthiness > worthiness_score:
            can_access = False
            restriction_reason = "worthiness"
        elif item.requires_besitos > besitos_balance:
            can_access = False
            restriction_reason = "besitos"
        elif item.required_vip and not has_vip:
            can_access = False
            restriction_reason = "vip_membership"

        if not can_access:
            # Modify item to show restriction elegantly
            item.lucien_voice_text = self._generate_restriction_explanation(
                item.id, restriction_reason, user_context
            )
            # Change action to explanation instead of purchase
            item.action_data = f"explain_restriction:{item.id}:{restriction_reason}"
        else:
            item.lucien_voice_text = self._generate_lucien_menu_text(
                item.id, item.description, user_context
            )

        return item

    def _generate_worthiness_explanation(self, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's explanation for worthiness requirements."""
        worthiness_score = user_context.get('worthiness_score', 0.0)
        required_worthiness = 0.6
        relationship_level = user_context.get('relationship_level', 'formal_examiner')
        sophistication_score = user_context.get('sophistication_score', 0.0)
        diana_encounters_earned = user_context.get('diana_encounters_earned', 0)

        # Enhanced explanation based on multiple factors
        if worthiness_score < 0.2:
            return (
                f"<b>El Div√°n</b> representa un nivel de intimidad y comprensi√≥n que debe ganarse "
                f"a trav√©s del desarrollo personal. Sus interacciones actuales (valor: {worthiness_score:.2f}) "
                f"sugieren que est√° en las etapas iniciales de este viaje de sofisticaci√≥n. "
                f"Contin√∫e explorando las experiencias disponibles para construir su perfil."
            )
        elif worthiness_score < 0.4:
            return (
                f"<b>El Div√°n</b> est√° reservado para quienes han demostrado un nivel excepcional "
                f"de madurez emocional. Su progreso es notable (valor: {worthiness_score:.2f}), "
                f"pero a√∫n requiere mayor profundidad en su comprensi√≥n. "
                f"Su relaci√≥n con Lucien actualmente es '{relationship_level}' y su nivel de sofisticaci√≥n es {sophistication_score:.2f}."
            )
        elif worthiness_score < 0.6:
            return (
                f"<b>El Div√°n</b> reconoce su crecimiento (valor: {worthiness_score:.2f}), "
                f"pero requiere la membres√≠a VIP para completar su acceso. "
                f"Su desarrollo personal ya demuestra la sofisticaci√≥n necesaria para estos privilegios. "
                f"Ha ganado {diana_encounters_earned} encuentros con Diana hasta ahora."
            )
        else:
            return (
                f"<b>‚ú® ¬°Felicidades! ‚ú®</b> Su perfil (valor: {worthiness_score:.2f}) "
                f"demuestra la madurez emocional y sofisticaci√≥n necesarias para <b>El Div√°n</b>. "
                f"Su relaci√≥n con Lucien es '{relationship_level}' y su nivel de sofisticaci√≥n es {sophistication_score:.2f}. "
                f"Para completar su acceso, se requiere membres√≠a VIP."
            )

    def _generate_restriction_explanation(self, item_id: str, restriction_type: str, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's elegant explanation for item restrictions."""
        worthiness_score = user_context.get('worthiness_score', 0.0)
        besitos_balance = user_context.get('besitos_balance', 100)

        if restriction_type == "worthiness":
            return (
                "Ciertos tesoros requieren un nivel de sofisticaci√≥n que se desarrolla "
                "naturalmente a trav√©s de sus interacciones. Su crecimiento personal "
                "determinar√° cu√°ndo estos privilegios se revelan."
            )
        elif restriction_type == "besitos":
            return (
                "Este tesoro particular requiere una inversi√≥n m√°s significativa de besitos. "
                "La paciencia y el progreso en sus misiones le proporcionar√°n los recursos necesarios."
            )
        elif restriction_type == "vip_membership":
            return (
                "Algunas experiencias est√°n cuidadosamente curadas para aquellos que han "
                "elegido un compromiso m√°s profundo con este mundo. La membres√≠a representa "
                "una invitaci√≥n a niveles de sofisticaci√≥n excepcionales."
            )
        else:
            return "Este privilegio requiere desarrollo adicional en m√∫ltiples √°reas."

    def _generate_store_header(self, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's sophisticated store introduction."""
        worthiness_score = user_context.get('worthiness_score', 0.0)
        besitos_balance = user_context.get('besitos_balance', 100)

        return (
            f"<b>‚ú® Cada objeto en esta colecci√≥n refleja un aspecto de la sofisticaci√≥n personal. "
            f"Sus {besitos_balance} besitos y su nivel actual de development determinan "
            f"qu√© tesoros resonar√°n con su journey. ‚ú®</b>"
        )

    def _generate_store_footer(self, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's sophisticated store conclusion."""
        return (
            "<i>Recuerde: las adquisiciones m√°s valiosas no son las que puede permitirse, "
            "sino las que ha ganado a trav√©s de su evoluci√≥n personal.</i>"
        )

    def _adapt_lucien_voice_to_user(self, user_context: Dict[str, Any]) -> None:
        """Adapt Lucien's voice profile based on user characteristics."""
        try:
            user_archetype = user_context.get('user_archetype', 'explorer')
            self.lucien_profile.adapt_to_archetype(user_archetype)

            narrative_level = user_context.get('narrative_level', 0)
            has_vip = user_context.get('has_vip', False)

            if narrative_level >= 4 and has_vip:
                self.lucien_profile.user_relationship_level = RelationshipLevel.TRUSTED_CONFIDANT
            elif narrative_level >= 2:
                self.lucien_profile.user_relationship_level = RelationshipLevel.RELUCTANT_APPRECIATOR
            else:
                self.lucien_profile.user_relationship_level = RelationshipLevel.FORMAL_EXAMINER

        except Exception as e:
            logger.warning(f"Failed to adapt Lucien voice profile: {e}")

    def _generate_lucien_menu_text(self, menu_context: str, base_observation: str, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's sophisticated voice text for menu items."""
        try:
            lucien_response = generate_lucien_response(
                self.lucien_profile, f"menu_access_{menu_context}", user_context
            )
            if lucien_response and lucien_response.response_text:
                return lucien_response.response_text[:200]
            return base_observation
        except Exception as e:
            logger.warning(f"Failed to generate Lucien menu text for {menu_context}: {e}")
            return base_observation

    def _generate_lucien_welcome_message(self, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's sophisticated welcome message for the main menu header."""
        try:
            lucien_response = generate_lucien_response(
                self.lucien_profile, "/start", user_context
            )
            if lucien_response and lucien_response.response_text:
                return f"<b>‚ú® {lucien_response.response_text} ‚ú®</b>"

            relationship_level = self.lucien_profile.user_relationship_level
            if relationship_level == RelationshipLevel.TRUSTED_CONFIDANT:
                return "<b>‚ú® Bienvenido a su mundo personal. Cada puerta aqu√≠ refleja su journey y sophistication excepcional ‚ú®</b>"
            elif relationship_level == RelationshipLevel.RELUCTANT_APPRECIATOR:
                return "<b>‚ú® Sus opciones se expanden conforme su development progresa. Algunas posibilidades aguardan mayor sophistication ‚ú®</b>"
            else:
                return "<b>‚ú® Este mundo se revela gradualmente a quienes demuestran worthiness. Cada elecci√≥n ser√° cuidadosamente evaluada ‚ú®</b>"
        except Exception as e:
            logger.warning(f"Failed to generate Lucien welcome message: {e}")
            return "<b>‚ú® Bienvenido a tu mundo con Diana ‚ú®</b>"

    def _generate_lucien_footer_message(self, user_context: Dict[str, Any]) -> str:
        """Generate Lucien's sophisticated footer message for the main menu."""
        try:
            worthiness_score = user_context.get('worthiness_score', 0.0)
            has_vip = user_context.get('has_vip', False)

            if has_vip and worthiness_score >= 0.8:
                return "<i>Sus elecciones reflejan el discernimiento y sophistication que he llegado a appreciate profundamente.</i>"
            elif worthiness_score >= 0.5:
                return "<i>Su development contin√∫a impresion√°ndome. Nuevas posibilidades se revelar√°n pronto.</i>"
            else:
                return "<i>Cada interacci√≥n contribuye a su evaluation. La paciencia y authenticity abren todas las puertas.</i>"
        except Exception as e:
            logger.warning(f"Failed to generate Lucien footer message: {e}")
            return "<i>Selecciona una opci√≥n para continuar tu journey</i>"


class NarrativeMenuBuilder(MenuBuilder):
    """Builder for narrative/Diana menu system."""

    def build_menu(self, user_context: Dict[str, Any], **kwargs) -> Menu:
        """Build narrative menu based on user progress."""
        try:
            user_context = self._validate_user_context(user_context)
            narrative_level = user_context.get('narrative_level', 0)
            has_vip = user_context.get('has_vip', False)
            current_fragment = user_context.get('current_fragment', 'start')
            completed_fragments = user_context.get('completed_fragments', [])
            user_id = user_context.get('user_id', 'unknown')
            parent_menu_id = kwargs.get('parent_menu_id', 'main_menu')

            logger.info(f"Building narrative menu for user {user_id} (level: {narrative_level}, vip: {has_vip})")

            items = []

            # Continuar Historia
            items.append(MenuItem(
                id="continue_story",
                text="<b>üìñ Continuar Historia</b>",
                action_type=ActionType.NARRATIVE_ACTION,
                action_data=f"continue_from:{current_fragment}",
                description="Contin√∫a donde te quedaste",
                icon="üìñ"
            ))

            # Los Kinkys (Niveles 1-3) - Acceso gratuito
            if narrative_level >= 1:
                items.append(MenuItem(
                    id="kinkys_level1",
                    text="<b>üå∏ Los Kinkys - Nivel 1</b>",
                    action_type=ActionType.NARRATIVE_ACTION,
                    action_data="level:kinkys_1",
                    description="El Umbral del Espejo",
                    icon="üå∏",
                    enabled_condition="level >= 1"
                ))

            if narrative_level >= 2:
                items.append(MenuItem(
                    id="kinkys_level2",
                    text="<b>üå∏ Los Kinkys - Nivel 2</b>",
                    action_type=ActionType.NARRATIVE_ACTION,
                    action_data="level:kinkys_2",
                    description="El Regreso del Observador",
                    icon="üå∏",
                    enabled_condition="level >= 2"
                ))

            if narrative_level >= 3:
                items.append(MenuItem(
                    id="kinkys_level3",
                    text="<b>üå∏ Los Kinkys - Nivel 3</b>",
                    action_type=ActionType.NARRATIVE_ACTION,
                    action_data="level:kinkys_3",
                    description="El Espejo del Deseo",
                    icon="üå∏",
                    enabled_condition="level >= 3"
                ))

            # El Div√°n (Niveles 4-6) - Requiere VIP
            if has_vip and narrative_level >= 4:
                items.append(MenuItem(
                    id="divan_level4",
                    text="<b>üõãÔ∏è El Div√°n - Nivel 4</b>",
                    action_type=ActionType.NARRATIVE_ACTION,
                    action_data="level:divan_4",
                    description="La Comprensi√≥n en Capas",
                    icon="üõãÔ∏è",
                    required_vip=True,
                    required_level=4
                ))

            if has_vip and narrative_level >= 5:
                items.append(MenuItem(
                    id="divan_level5",
                    text="<b>üõãÔ∏è El Div√°n - Nivel 5</b>",
                    action_type=ActionType.NARRATIVE_ACTION,
                    action_data="level:divan_5",
                    description="La Profundizaci√≥n Suprema",
                    icon="üõãÔ∏è",
                    required_vip=True,
                    required_level=5
                ))

            if has_vip and narrative_level >= 6:
                items.append(MenuItem(
                    id="circulo_intimo",
                    text="<b>üí´ C√≠rculo √çntimo</b>",
                    action_type=ActionType.NARRATIVE_ACTION,
                    action_data="level:circulo_intimo",
                    description="M√°s All√° del Final",
                    icon="üí´",
                    required_vip=True,
                    required_level=6
                ))

            # Fragmentos de Memoria
            if len(completed_fragments) > 0:
                items.append(MenuItem(
                    id="memory_fragments",
                    text="<b>üß© Fragmentos de Memoria</b>",
                    action_type=ActionType.CALLBACK,
                    action_data="show_memory_fragments",
                    description="Revive momentos especiales",
                    icon="üß©"
                ))

            # An√°lisis Emocional - Solo VIP
            if has_vip:
                items.append(MenuItem(
                    id="emotional_analysis",
                    text="<b>üí≠ An√°lisis Emocional</b>",
                    action_type=ActionType.CALLBACK,
                    action_data="show_emotional_analysis",
                    description="Tu perfil emocional con Diana",
                    icon="üí≠",
                    required_vip=True
                ))

            menu = Menu(
                menu_id="narrative_menu",
                title="üé≠ Historia con Diana",
                description=f"Tu nivel actual: {narrative_level}",
                menu_type=MenuType.NARRATIVE,
                required_role=UserRole.FREE_USER,
                items=items,
                header_text="<b>üåü Explora tu historia con Diana üåü</b>",
                is_dynamic=True,
                parent_menu_id=parent_menu_id,
                navigation_path=kwargs.get('navigation_path', [])
            )

            self._log_menu_creation("narrative_menu", user_id, True)
            return menu

        except Exception as e:
            self._log_menu_creation("narrative_menu", user_context.get('user_id', 'unknown'), False, str(e))
            raise MenuGenerationError(f"Failed to build narrative menu: {str(e)}") from e


class AdminMenuBuilder(MenuBuilder):
    """Builder for administrative menu system."""

    def build_menu(self, user_context: Dict[str, Any], **kwargs) -> Menu:
        """Build admin menu based on admin role."""
        try:
            user_context = self._validate_user_context(user_context)
            user_role = UserRole(user_context.get('role', 'admin'))
            user_id = user_context.get('user_id', 'unknown')
            parent_menu_id = kwargs.get('parent_menu_id', 'main_menu')

            logger.info(f"Building admin menu for user {user_id} (role: {user_role.value})")

            items = []

            # Gesti√≥n de Usuarios
            items.append(MenuItem(
                id="user_management",
                text="<b>üë• Gesti√≥n de Usuarios</b>",
                action_type=ActionType.SUBMENU,
                action_data="admin_users_menu",
                description="Administrar usuarios del sistema",
                required_role=UserRole.ADMIN
            ))

            # Gesti√≥n de Contenido Narrativo
            items.append(MenuItem(
                id="narrative_management",
                text="<b>üìù Gesti√≥n de Narrativa</b>",
                action_type=ActionType.SUBMENU,
                action_data="admin_narrative_menu",
                description="Crear y editar contenido narrativo",
                required_role=UserRole.ADMIN
            ))

            # An√°lisis de Comportamiento
            items.append(MenuItem(
                id="behavior_analytics",
                text="<b>üìä An√°lisis Comportamental</b>",
                action_type=ActionType.CALLBACK,
                action_data="show_behavior_analytics",
                description="Estad√≠sticas de comportamiento emocional",
                required_role=UserRole.ADMIN
            ))

            # Sistema de Recompensas
            items.append(MenuItem(
                id="reward_management",
                text="<b>üéÅ Gesti√≥n de Recompensas</b>",
                action_type=ActionType.SUBMENU,
                action_data="admin_rewards_menu",
                description="Configurar sistema de recompensas",
                required_role=UserRole.ADMIN
            ))

            # Configuraci√≥n del Sistema
            items.append(MenuItem(
                id="system_config",
                text="<b>‚öôÔ∏è Configuraci√≥n</b>",
                action_type=ActionType.SUBMENU,
                action_data="admin_config_menu",
                description="Configuraci√≥n del sistema",
                required_role=UserRole.ADMIN
            ))

            # Logs y Monitoreo - Solo Super Admin
            if user_role == UserRole.SUPER_ADMIN:
                items.append(MenuItem(
                    id="system_monitoring",
                    text="<b>üìà Monitoreo del Sistema</b>",
                    action_type=ActionType.CALLBACK,
                    action_data="show_system_monitoring",
                    description="Logs y m√©tricas del sistema",
                    required_role=UserRole.SUPER_ADMIN
                ))

            # Base de Datos - Solo Super Admin
            if user_role == UserRole.SUPER_ADMIN:
                items.append(MenuItem(
                    id="database_management",
                    text="<b>üóÑÔ∏è Gesti√≥n BD</b>",
                    action_type=ActionType.SUBMENU,
                    action_data="admin_database_menu",
                    description="Administraci√≥n de base de datos",
                    required_role=UserRole.SUPER_ADMIN
                ))

            menu = Menu(
                menu_id="admin_menu",
                title="‚öôÔ∏è Panel de Administraci√≥n",
                description="Herramientas administrativas",
                menu_type=MenuType.ADMIN,
                required_role=UserRole.ADMIN,
                items=items,
                header_text="<b>üîß Panel de Administraci√≥n üîß</b>"
            )

            self._log_menu_creation("admin_menu", user_id, True)
            return menu

        except Exception as e:
            self._log_menu_creation("admin_menu", user_context.get('user_id', 'unknown'), False, str(e))
            raise MenuGenerationError(f"Failed to build admin menu: {str(e)}") from e


class VIPMenuBuilder(MenuBuilder):
    """Builder for VIP exclusive menu system."""

    def build_menu(self, user_context: Dict[str, Any]) -> Menu:
        """Build VIP menu with exclusive content."""
        narrative_level = user_context.get('narrative_level', 0)

        items = []

        # Acceso al Div√°n
        items.append(MenuItem(
            id="divan_exclusive",
            text="<b>üõãÔ∏è El Div√°n Privado</b>",
            action_type=ActionType.NARRATIVE_ACTION,
            action_data="divan:private_access",
            description="Tu espacio √≠ntimo con Diana",
            required_vip=True
        ))

        # Archivo Personal de Diana
        items.append(MenuItem(
            id="diana_personal_archive",
            text="<b>üìö Archivo Personal de Diana</b>",
            action_type=ActionType.CALLBACK,
            action_data="show_diana_archive",
            description="Memorias √≠ntimas y reflexiones",
            required_vip=True,
            required_level=4
        ))

        # Diario √çntimo
        if narrative_level >= 5:
            items.append(MenuItem(
                id="diana_intimate_diary",
                text="<b>üìñ Diario √çntimo de Diana</b>",
                action_type=ActionType.CALLBACK,
                action_data="show_intimate_diary",
                description="Pensamientos m√°s profundos",
                required_vip=True,
                required_level=5
            ))

        # Contenido Exclusivo
        items.append(MenuItem(
            id="exclusive_content",
            text="<b>‚ú® Contenido Exclusivo</b>",
            action_type=ActionType.SUBMENU,
            action_data="vip_exclusive_menu",
            description="Solo para miembros VIP",
            required_vip=True
        ))

        # Sesiones Personalizadas
        items.append(MenuItem(
            id="personalized_sessions",
            text="<b>üí´ Sesiones Personalizadas</b>",
            action_type=ActionType.CALLBACK,
            action_data="start_personalized_session",
            description="Experiencias adaptadas a ti",
            required_vip=True
        ))

        return Menu(
            menu_id="vip_menu",
            title="üíé √Årea VIP",
            description="Contenido exclusivo para miembros VIP",
            menu_type=MenuType.VIP,
            required_role=UserRole.VIP_USER,
            items=items,
            header_text="<b>üíé Bienvenido al √Årea VIP üíé</b>",
            footer_text="<i>Contenido exclusivo dise√±ado para ti</i>"
        )


class MenuValidationUtils:
    """Utility class for menu validation and optimization."""

    @staticmethod
    def validate_callback_data_length(data: str) -> bool:
        """Check if callback data is within Telegram limits."""
        return len(data.encode('utf-8')) <= TELEGRAM_CALLBACK_DATA_MAX_LENGTH

    @staticmethod
    def optimize_menu_hierarchy(menu: Menu, max_depth: int = 3) -> Menu:
        """Optimize menu hierarchy to reduce navigation depth."""
        if len(menu.navigation_path) > max_depth:
            # Flatten submenu items if hierarchy is too deep
            flattened_items = []
            for item in menu.items:
                if item.action_type == ActionType.SUBMENU and item.submenu_items:
                    # Convert submenu items to regular items with prefixed names
                    for subitem in item.submenu_items:
                        flattened_item = MenuItem(
                            id=f"{item.id}_{subitem.id}",
                            text=f"{item.icon} {subitem.text}",
                            action_type=subitem.action_type,
                            action_data=subitem.action_data,
                            description=f"{item.text}: {subitem.description}",
                            required_role=subitem.required_role,
                            required_vip=subitem.required_vip,
                            required_level=subitem.required_level
                        )
                        flattened_items.append(flattened_item)
                else:
                    flattened_items.append(item)

            menu.items = flattened_items
            logger.info(f"Flattened menu hierarchy for '{menu.menu_id}' - reduced depth")

        return menu

    @staticmethod
    def add_performance_metadata(menu: Menu) -> Menu:
        """Add performance metadata to menu for analytics."""
        menu.metadata = menu.metadata or {}
        menu.metadata.update({
            'created_at': datetime.now().isoformat(),
            'item_count': len(menu.items),
            'has_vip_items': any(item.required_vip for item in menu.items),
            'max_role_required': max((item.required_role for item in menu.items), default=UserRole.FREE_USER, key=lambda x: x.value)
        })
        return menu


from src.utils.cache_manager import cache_manager



class MenuFactory:
    """Main factory class for generating menus based on context."""

    def __init__(self, user_service: Optional[UserService] = None):
        """Initialize menu factory with builders.
        
        Args:
            user_service (Optional[UserService]): UserService instance for delegation of complex operations
        """
        self.user_service = user_service
        self.builders = {
            MenuType.MAIN: MainMenuBuilder(),  # Use organic main menu builder
            MenuType.NARRATIVE: NarrativeMenuBuilder(),
            MenuType.ADMIN: AdminMenuBuilder(),
            MenuType.VIP: VIPMenuBuilder(),
            MenuType.STORE: MainMenuBuilder(),  # Use organic main menu builder for store too
            MenuType.GAMIFICATION: MainMenuBuilder(),
            MenuType.PROFILE: MainMenuBuilder(),
            MenuType.EMOTIONAL: MainMenuBuilder(),
            MenuType.DIANA: MainMenuBuilder(),
            MenuType.SETTINGS: MainMenuBuilder(),
            MenuType.HELP: MainMenuBuilder()
        }

        self.menu_definitions = self._initialize_menu_definitions()
        self.cache_manager = cache_manager
        # Initialize cache connection only when running in async context
        # Use a flag to track if we're connected to avoid multiple connection attempts
        self._cache_connected = False
        # Callback data mapping for compression
        self.callback_mapping = {}
        logger.info("MenuFactory initialized (cache connection will be established on first use)")

    def _initialize_menu_definitions(self) -> Dict[str, Dict]:
        """Initialize static menu definitions for organic menu system."""
        # Use centralized menu definitions
        return menu_system_config.definitions

    async def create_menu(self, menu_type: Union[MenuType, str], user_context: Dict[str, Any], **kwargs) -> Menu:
        """Create menu based on type and user context, with caching."""
        # Try to use cache if available and connected
        try:
            if not self._cache_connected:
                await self.cache_manager.connect()
                self._cache_connected = True
                logger.info("Cache manager connected successfully")
            
            # Convert string menu_type to MenuType enum if needed
            if isinstance(menu_type, str):
                try:
                    menu_type = MenuType(menu_type)
                except ValueError:
                    logger.warning(f"Invalid menu type '{menu_type}', defaulting to MAIN")
                    menu_type = MenuType.MAIN
            
            cached_menu = await self.cache_manager.get_menu(menu_type.value, user_context)
            if cached_menu:
                return cached_menu
        except Exception as e:
            logger.warning(f"Cache operation failed, proceeding without cache: {str(e)}")
            # Continue without cache if there's an error

        # Build the menu
        if menu_type in self.builders:
            new_menu = self.builders[menu_type].build_menu(user_context, **kwargs)
        else:
            # Try to get from centralized definitions
            menu_config = menu_system_config.get_menu_definition(menu_type.value)
            if menu_config:
                new_menu = Menu.from_config(menu_config, user_context)
            else:
                new_menu = self._create_basic_menu(menu_type, user_context)

        # Try to cache the new menu
        try:
            if self._cache_connected:
                await self.cache_manager.set_menu(new_menu, user_context)
        except Exception as e:
            logger.warning(f"Failed to cache menu: {str(e)}")
            
        return new_menu

    async def create_organic_store_menu(self, user_context: Dict[str, Any]) -> Menu:
        """Create organic unified store menu."""
        main_builder = self.builders[MenuType.STORE]
        if hasattr(main_builder, 'build_organic_store_menu'):
            return main_builder.build_organic_store_menu(user_context)
        else:
            return await self.create_menu(MenuType.STORE, user_context)

    def create_menu_by_id(self, menu_id: str, user_context: Dict[str, Any]) -> Optional[Menu]:
        """Create menu by specific ID using organic system."""
        if menu_id in self.menu_definitions:
            return self._create_organic_menu_from_definition(menu_id, user_context)
        elif menu_id == "organic_store_menu":
            main_builder = self.builders[MenuType.STORE]
            if hasattr(main_builder, 'build_organic_store_menu'):
                return main_builder.build_organic_store_menu(user_context)
        return None

    def _create_organic_menu_from_definition(self, menu_id: str, user_context: Dict[str, Any]) -> Menu:
        """Create menu from static definition using organic principles."""
        definition = self.menu_definitions.get(menu_id)
        if not definition:
            # Fallback to basic menu
            return self._create_basic_menu(MenuType.MAIN, user_context)
            
        main_builder = self.builders[MenuType.MAIN]  # Use main builder

        items = []
        for item_def in definition.get("items", []):
            # Always show items, but process restrictions organically
            item = MenuItem(
                id=item_def.get("id", ""),
                text=item_def.get("text", ""),
                action_type=ActionType(item_def.get("action_type", ActionType.CALLBACK)),
                action_data=item_def.get("action", item_def.get("action_data", "")),
                description=item_def.get("description", ""),
                required_role=UserRole(item_def.get("required_role", "free_user")),
                required_vip=item_def.get("required_vip", False),
                required_level=item_def.get("required_level", 0),
                requires_besitos=item_def.get("requires_besitos", 0),
                required_worthiness=item_def.get("required_worthiness", 0.0)
            )

            # Process with organic restrictions
            if hasattr(main_builder, '_process_store_item'):
                item = main_builder._process_store_item(item, user_context)

            items.append(item)

        return Menu(
            menu_id=menu_id,
            title=definition.get("title", "Men√∫"),
            description=definition.get("description", "Cada opci√≥n refleja tu journey personal"),
            menu_type=MenuType(definition.get("menu_type", "profile")),
            required_role=UserRole(definition.get("required_role", "free_user")),
            items=items,
            header_text=definition.get("header_text", ""),
            footer_text=definition.get("footer_text", ""),
            max_columns=definition.get("max_columns", 2),
            is_dynamic=definition.get("is_dynamic", False),
            parent_menu_id=definition.get("parent_menu_id", "main_menu"),
            navigation_path=definition.get("navigation_path", [])
        )

    def _user_meets_organic_requirements(self, item_def: Dict, user_context: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
        """Check if user meets requirements using organic system (always visible, elegant restrictions)."""
        # In organic system, everything is visible but elegantly restricted
        restriction_reason = None

        required_vip = item_def.get("required_vip", False)
        has_vip = user_context.get("has_vip", False)

        required_worthiness = item_def.get("required_worthiness", 0.0)
        user_worthiness = user_context.get("worthiness_score", 0.0)

        if required_vip and not has_vip:
            restriction_reason = "vip_membership"
        elif required_worthiness > user_worthiness:
            restriction_reason = "worthiness"

        return True, restriction_reason  # Always visible, restriction noted

    def _role_has_access(self, user_role: UserRole, required_role: UserRole) -> bool:
        """Check if user role has access to required role."""
        role_hierarchy = {
            UserRole.GUEST: 0,
            UserRole.FREE_USER: 1,
            UserRole.VIP_USER: 2,
            UserRole.ADMIN: 3,
            UserRole.SUPER_ADMIN: 4
        }

        return role_hierarchy[user_role] >= role_hierarchy[required_role]

    def _create_basic_menu(self, menu_type: MenuType, user_context: Dict[str, Any]) -> Menu:
        """Create basic fallback menu."""
        return Menu(
            menu_id="basic_menu",
            title="üìã Men√∫ B√°sico",
            description="Men√∫ b√°sico del sistema",
            menu_type=menu_type,
            required_role=UserRole.FREE_USER,
            items=[
                MenuItem(
                    id="back_to_main",
                    text="<b>üîô Volver al Men√∫ Principal</b>",
                    action_type=ActionType.CALLBACK,
                    action_data="main_menu",
                    description="Regresar al men√∫ principal"
                )
            ]
        )


# Global menu factory instance
menu_factory = MenuFactory()


async def get_menu_for_user(menu_type: Union[MenuType, str], user_context: Dict[str, Any]) -> Menu:
    """Convenience function to get menu for user."""
    if isinstance(menu_type, str):
        menu = menu_factory.create_menu_by_id(menu_type, user_context)
        if menu:
            return menu

        try:
            menu_type = MenuType(menu_type)
        except ValueError:
            menu_type = MenuType.MAIN

    return await menu_factory.create_menu(menu_type, user_context)
